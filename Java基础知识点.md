# 一、面向对象

## Java面向对象有哪些特征？

​		面向对象编程是利用类和对象编程的一种思想。就是万物可归类，万物皆对象。

​		面向对象的三大特征 ，封装、继承、多态。

​		封装说明一个类行为和属性与其他类的关系，低耦合，高内聚。继承是父类和子类的关系。多态是一个类和多个类的关系。

​		封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。暴漏给外界的只是它的访问方法。

​		封装属性：使用者只能通过事先定制好的方法来访问数据，限制对数据的不合理操作。

​		封装方法：按照既定的方式去调用方法，而不必去关心方法的内部实现。

​		继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并且能扩展新的能力。我们可以在多种实现类中抽象出一个基类，使其具备多种实现类的共同特性。父类中通过private定义的变量和方法是不能被继承，不能在子类中直接操作。运用继承原则也是使得系统模型比较简洁清晰。

​		相比于继承和封装，Java多态是三大特性中比较难的一个，封装和继承最后都归结于多态，多态指的是类和类的关系，两个类有继承关系，存在有方法的重写，故而可以在调用时有父类引用指向子类对象。所以说多态必备的三个要素：继承、重写和父类引用指向子类对象。

##  Java中基本数据类型

​		八种数据类型。

​		Byte 1，short和char 2，int和float 4，double和long 8，还有一个布尔类型。

​		除了int是Integer，char是Character，其他的几种都是首字母大写。

## Java接口和抽象类有哪些区别？

​		相同点：1.不能够实例化

​						2.可以将抽象类和接口作为引用类型

​						3.一个类如果继承了某个抽象类或者实现了某个接口，都需要对其中的抽象方法全部进行实现，否则该类任然需要被声明为抽象类。

​		不同点：1.抽象类中可以定义构造器，接口不行。

​						2.抽象类中可以有抽象方法和具体方法，接口中的方法全部是抽象方法。

​						3.抽象类中的成员可以是private，默认，protected，public，接口中全都是public

​						4.抽象类中可以定义成员变量，接口中定义的成员变量实际上都是常量。

​						5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。

​						6.抽象类中可以包含静态方法，接口中不能用静态方法。

​						7.一个类只能继承一个抽象类，但可以实现多个接口。

## ==和equals有哪些区别？

​		最大的区别是一个是方法，一个是运算符。

​		==：如果比较的是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，比较的就是对象的地址值是否相等。

​		equals：用来比较方法的两个对象的内容是否相等，它不能用来比较基本数据类型的变量，如果没有对equals方法进行重写，则比较的是引用类型变量所指向的对象的地址。

## 重写和重载有哪些区别？

​		方法的重写和重载都是实现多态的方式，区别在于前者实现的是编译时的多态性，后者实现的是运行时的多态性。

​		重载发生在一个类中，同名的方法有不同的参数列表（顺序，类型，个数不同）。

​		重写发生在子类和父类之间，重写要求参数列表和返回类型必须与被重写的方法一致。而重载对于返回类型没有要求。

​		还有就是构造方法不能被重写，声明为final，static的方法不能被重写。

## 怎样声明一个类不会被继承，什么场景下会用？

​		如果一个类被final修饰，这个类就不能有子类，就不会被继承，也就不会出现方法的重写这个情况。如果一个类，比如Math类，这个类里面所有的方法都没有重写的需要，他有没有子类也无所谓的话，就可以用final修饰类。



# 二、异常

## Java异常处理的方式

​		Java是通过面向对象的方法进行异常处理，每个异常都是一个对象，它是Throwable类或其子类的实例，当一个方法出现异常后，便抛出一个异常对象，该对象包含有异常信息，调用这个对象的方法可以捕获到这个异常并对其进行处理，主要有五个关键字：try，catch，finally，throw，throws。

​		它又分为三种，抛出异常是throw，捕获异常是try，catch，finally，声明异常是throws。

​		try，catch，finally就是进行异常的捕获，将可能出现异常的代码放到try里面，只要捕获到异常就会跟catch里面的异常类型进行一个匹配，匹配成功了就会执行catch里面的处理的一个逻辑，所以catch可以进行一个多重catch，比如说出现多个异常，就写多个catch进行处理，然后finally里面一般进行一些资源的关闭，比如说IO流的关闭，网络资源的关闭，因为它是无论是否出现异常，finally里面的代码都会执行。

## throw和throws的区别：

​		1.位置不同：throw在方法的内部，throws在方法的声明处。

​		2.内容不同：throw异常对象（检查时异常，运行时异常），throws异常的类型（可以多个类型，用，拼接）

​		3.作用不同：throw：异常出现的源头，制造异常，throws：在方法的声明处，告诉方法的调用者，这个方法中可能会出现我声明的这些异常，然后调用者对这个异常进行处理，要么自己处理，要么继续向外抛出异常。







# 三、常用类

## String，StringBuffer，StringBuilder的区别及使用场景

​		String是只读字符串，也就是不可变的。

​		StringBuffer和StringBuilder表示的字符串对象之间可以进行修改。

​		StringBuilder是JDK5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方法都没有被Synchronized修饰，因此它不是线程安全的，但是效率理论上会比StringBuffer要高。

# 四、IO流

## File类

​		它是文件和目录路径名的抽象表示。

​		java中万物皆对象，文件和目录是可以将它的各种信息封装成一个File类的对象。有了这个对象，我们程序就可以直接操纵这个对象，通过这个对象获取文件的各种信息，还可以对文件进行创建，删除。

​		对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已，它可以是存在的，也可以是不存在的。通过具体的操作可以把这个路径的内容转换为具体存在的。

```java
构造方法：
File(String pathname):通过将给定的路径名字符串转换为抽象路径名来创建新的File实例 pathname
File(String parent,String child):从父路径名字符串和子路径字符串创建新的File实例 parent+child = pathname
File(File parent,String child):从父抽象路径名和子路径名字符串创建新的File实例 parent.getPath() + child = pathname
    
File类创建功能：
public boolean createNewFile()：当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件：
注意：创建文件时目录必须存在，否则创建失败
public boolean mkdir()：创建由此抽象路径命名的单层目录
public boolean mkdirs()： 创建由此抽象路径命名的多层目录
    
File类判断和获取功能：
public boolean isDirectory()：测试此抽象路径名表示的File是否为目录
public boolean isFile()： 测试此抽象路径名表示的File是否为文件
public boolean isHidden():测试此抽象路径名表示的File是否隐藏
public boolean exists()： 测试此抽象路径名表示的File是否存在
public boolean canRead():  文件是否可读
public boolean canWrite():  文件是否可写
public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串
public String getPath()： 将此抽象路径名转换为路径名字符串
public String getParent(): 返回上级目录
public String getName()： 返回此抽象路径名表示的文件或目录的名称
public String length():  返回文件的大小
public String[] list()： 返回此抽象路径名表示的目录中的文件和目录的名称字符串数组
public File[] listFiles()： 返回此抽象路径名表示的目录中的文件和目录的File对象数组
    
File类删除功能：
public boolean delete()：删除由此抽象路径名表示的文件或目录
注意：删除目录时需要将目录中的所有文件全部删除后才可以继续删除当前目录
```



## IO流

​		File类封装文件或目录的各种信息，对它们进行操作，但是我们不能获取到文件或目录中的内容，所以就有了IO流。

​		IO是Input和Output的缩写。

​		形象理解的话，就是一根管子，程序和数据源之间沟通的桥梁。

​		Test.txt（数据源，文件，内存，数据库资源，网络资源，IO资源等）-->输入

​		程序 --> 输出

​		目标位置

### **IO流的分类：**

| 按照方向/安装处理数据的单位 | 字节流       | 字符流 |
| --------------------------- | ------------ | ------ |
| 输入流                      | InputStream  | Reader |
| 输出流                      | OutputStream | Writer |

​		按照功能：节点流：单独的一根”管“，处理数据对应的那个流。

​							处理流：”管“套着”管“，组合使用

​		这四个就是抽象基类，四个抽象类。

### IO流的体系结构

![image-20220529050511390](https://raw.githubusercontent.com/Jayfei-Wu/NotePic/master/pic/image-20220529050511390.png)

​		

















# 五、多线程

## 继承Thread类

### 执行过程

​		定义一个类MyThread继承Thread类

​		在MyThread类中重写run()方法

​		创建MyThread类的对象

​		调用start()方法启动线程

### 为什么要重写run()方法？

​		因为run()是用来封装被线程执行的代码

### run()和start()方法的区别？

​		run(): 封装线程执行的代码，直接调用，相当于普通方法的调用

​		start(): 启动线程，然后由JVM调用此线程的run()方法

### 设置和获取线程名称

​		void setName(String name): 更改线程名称

​		String getName(): 返回此线程的名称

​		通过构造方法也可以设置线程名称

​		获取main()方法所在的线程名称？

​		public static Thread currentThread(): 返回对当前正在执行的线程对象的引用

### 线程调度

​		分时调度模型：所有线程轮流使用CPU使用权，平均分配每个线程占用CPU的时间片

​		抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片想对多一些

​		Java中使用的是抢占式调度模型

​		**Thread类中设置和获取线程优先级的方法**

​				public final iint getPriority(): 返回此线程的优先级

​				public final void setPriority(int newPriority): 更改此线程的优先级

​				线程默认优先级是5，优先级范围1-10

### 线程控制

​		static void sleep(long millis): 是当前正在执行的线程停留（暂停执行）指定的毫秒数

​		void join(): 等待这个线程死亡，如果给当前线程对象调用了此方法，那么其他线程只有当此线程执行完毕后才会执行

​		void setDaemon(boolean on): 必须在线程启动之前调用此方法，将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出

## 实现Runnable接口

### 执行过程

​		定义一个类MyRunnable实现Runnable接口

​		在MyRunnable类中重写run()方法

​		创建MyRunnable类的对象

​		创建Thread类的对象，将MyRunnable对象最为构造方法的参数

​		启动线程

### 相比继承Thread类，实现Runnable接口的好处

​		避免了Java单继承的局限性

​		适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码，数据有效分离，较好的体现了面向对象的设计思想



## 多线程引发的数据安全问题及解决方案

## 线程生命周期

​		新生状态 --> start()启动 --> 就绪状态（有资格，没资源，没有CPU）

​		就绪状态 --> run()获取CPU的执行权 --> 运行状态（有资格，有资源，有CPU调度）

​		运行状态下有四种方向

​		synchronized --> 进入锁池状态 --> 返回到就绪状态

​		wait() --> 进入等待队列 --> 通过notify，notifyall唤醒进入到锁池状态

​		Join(),sleep() 制造阻塞事件 --> 进入阻塞状态 -->阻塞状态结束进入就绪状态

​		最后一种就是程序正常结束或者出现异常，就会进入死亡状态。 





# 六、集合





# 七、Mysql

## Mysql的隔离级别？

​		四种隔离级别

​		读未提交，读已提交，可重复读，串行化。

​		导致三种读的问题

​		脏读，不可重复读，幻读。

## 事务的基本特性？

​		原子性：一个事务要么完整执行，要么不执行。

​		一致性：代表了底层数据存储的完整性，事务系统通过保证事务的原子性，隔离性和持久性来满足这个要求。

​		隔离性：意味着事务必须在不干扰其他进程或事务的前提下独立运行。

​		持久性：表示在某个事务的执行过程中，对数据所做的所有改动，都必须在事务成功结束前保存至某种存储设备，这样可以保证，所做的修改在任何系统瘫痪时不至于丢失。

